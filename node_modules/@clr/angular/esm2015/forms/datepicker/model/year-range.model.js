/*
 * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
const YEARS_TO_DISPLAY = 10;
export class YearRangeModel {
    constructor(year) {
        this.year = year;
        this.yearRange = [];
        this.generateYearRange();
    }
    /**
     * Gets the number in the middle of the range.
     */
    get middleYear() {
        return this.yearRange[Math.floor(this.yearRange.length / 2)];
    }
    /**
     * Generates the year range based on the year parameter.
     * eg: If 2018 is passed the output will be [2010, 2011, ..., 2019]
     */
    generateYearRange() {
        const remainder = this.year % YEARS_TO_DISPLAY;
        const floor = this.year - remainder;
        const ceil = floor + YEARS_TO_DISPLAY;
        this.yearRange = this.generateRange(floor, ceil);
    }
    /**
     * Function which generate a range of numbers from floor to ceil.
     */
    generateRange(floor, ceil) {
        return Array.from({ length: ceil - floor }, (_v, k) => k + floor);
    }
    /**
     * Generates the YearRangeModel for the next decade.
     */
    nextDecade() {
        return new YearRangeModel(this.year + 10);
    }
    /**
     * Generates the YearRangeModel for the previous decade.
     */
    previousDecade() {
        return new YearRangeModel(this.year - 10);
    }
    /**
     * Generates the YearRangeModel for the current decade.
     */
    currentDecade() {
        return new YearRangeModel(new Date().getFullYear());
    }
    /**
     * Checks if the value is in the YearRangeModel.
     */
    inRange(value) {
        return this.yearRange.indexOf(value) > -1;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWVhci1yYW5nZS5tb2RlbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2Nsci1hbmd1bGFyL3NyYy9mb3Jtcy9kYXRlcGlja2VyL21vZGVsL3llYXItcmFuZ2UubW9kZWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7R0FJRztBQUVILE1BQU0sZ0JBQWdCLEdBQUcsRUFBRSxDQUFDO0FBRTVCLE1BQU0sT0FBTyxjQUFjO0lBQ3pCLFlBQTZCLElBQVk7UUFBWixTQUFJLEdBQUosSUFBSSxDQUFRO1FBSXpDLGNBQVMsR0FBYSxFQUFFLENBQUM7UUFIdkIsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7SUFDM0IsQ0FBQztJQUlEOztPQUVHO0lBQ0gsSUFBSSxVQUFVO1FBQ1osT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMvRCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssaUJBQWlCO1FBQ3ZCLE1BQU0sU0FBUyxHQUFXLElBQUksQ0FBQyxJQUFJLEdBQUcsZ0JBQWdCLENBQUM7UUFDdkQsTUFBTSxLQUFLLEdBQVcsSUFBSSxDQUFDLElBQUksR0FBRyxTQUFTLENBQUM7UUFDNUMsTUFBTSxJQUFJLEdBQVcsS0FBSyxHQUFHLGdCQUFnQixDQUFDO1FBQzlDLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDbkQsQ0FBQztJQUVEOztPQUVHO0lBQ0ssYUFBYSxDQUFDLEtBQWEsRUFBRSxJQUFZO1FBQy9DLE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLE1BQU0sRUFBRSxJQUFJLEdBQUcsS0FBSyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUM7SUFDcEUsQ0FBQztJQUVEOztPQUVHO0lBQ0gsVUFBVTtRQUNSLE9BQU8sSUFBSSxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxjQUFjO1FBQ1osT0FBTyxJQUFJLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQzVDLENBQUM7SUFFRDs7T0FFRztJQUNILGFBQWE7UUFDWCxPQUFPLElBQUksY0FBYyxDQUFDLElBQUksSUFBSSxFQUFFLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxPQUFPLENBQUMsS0FBYTtRQUNuQixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQzVDLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAyMCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuY29uc3QgWUVBUlNfVE9fRElTUExBWSA9IDEwO1xuXG5leHBvcnQgY2xhc3MgWWVhclJhbmdlTW9kZWwge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHllYXI6IG51bWJlcikge1xuICAgIHRoaXMuZ2VuZXJhdGVZZWFyUmFuZ2UoKTtcbiAgfVxuXG4gIHllYXJSYW5nZTogbnVtYmVyW10gPSBbXTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIGluIHRoZSBtaWRkbGUgb2YgdGhlIHJhbmdlLlxuICAgKi9cbiAgZ2V0IG1pZGRsZVllYXIoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy55ZWFyUmFuZ2VbTWF0aC5mbG9vcih0aGlzLnllYXJSYW5nZS5sZW5ndGggLyAyKV07XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSB5ZWFyIHJhbmdlIGJhc2VkIG9uIHRoZSB5ZWFyIHBhcmFtZXRlci5cbiAgICogZWc6IElmIDIwMTggaXMgcGFzc2VkIHRoZSBvdXRwdXQgd2lsbCBiZSBbMjAxMCwgMjAxMSwgLi4uLCAyMDE5XVxuICAgKi9cbiAgcHJpdmF0ZSBnZW5lcmF0ZVllYXJSYW5nZSgpIHtcbiAgICBjb25zdCByZW1haW5kZXI6IG51bWJlciA9IHRoaXMueWVhciAlIFlFQVJTX1RPX0RJU1BMQVk7XG4gICAgY29uc3QgZmxvb3I6IG51bWJlciA9IHRoaXMueWVhciAtIHJlbWFpbmRlcjtcbiAgICBjb25zdCBjZWlsOiBudW1iZXIgPSBmbG9vciArIFlFQVJTX1RPX0RJU1BMQVk7XG4gICAgdGhpcy55ZWFyUmFuZ2UgPSB0aGlzLmdlbmVyYXRlUmFuZ2UoZmxvb3IsIGNlaWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHdoaWNoIGdlbmVyYXRlIGEgcmFuZ2Ugb2YgbnVtYmVycyBmcm9tIGZsb29yIHRvIGNlaWwuXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlUmFuZ2UoZmxvb3I6IG51bWJlciwgY2VpbDogbnVtYmVyKTogbnVtYmVyW10ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBjZWlsIC0gZmxvb3IgfSwgKF92LCBrKSA9PiBrICsgZmxvb3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgWWVhclJhbmdlTW9kZWwgZm9yIHRoZSBuZXh0IGRlY2FkZS5cbiAgICovXG4gIG5leHREZWNhZGUoKTogWWVhclJhbmdlTW9kZWwge1xuICAgIHJldHVybiBuZXcgWWVhclJhbmdlTW9kZWwodGhpcy55ZWFyICsgMTApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgWWVhclJhbmdlTW9kZWwgZm9yIHRoZSBwcmV2aW91cyBkZWNhZGUuXG4gICAqL1xuICBwcmV2aW91c0RlY2FkZSgpOiBZZWFyUmFuZ2VNb2RlbCB7XG4gICAgcmV0dXJuIG5ldyBZZWFyUmFuZ2VNb2RlbCh0aGlzLnllYXIgLSAxMCk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSBZZWFyUmFuZ2VNb2RlbCBmb3IgdGhlIGN1cnJlbnQgZGVjYWRlLlxuICAgKi9cbiAgY3VycmVudERlY2FkZSgpOiBZZWFyUmFuZ2VNb2RlbCB7XG4gICAgcmV0dXJuIG5ldyBZZWFyUmFuZ2VNb2RlbChuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgdmFsdWUgaXMgaW4gdGhlIFllYXJSYW5nZU1vZGVsLlxuICAgKi9cbiAgaW5SYW5nZSh2YWx1ZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMueWVhclJhbmdlLmluZGV4T2YodmFsdWUpID4gLTE7XG4gIH1cbn1cbiJdfQ==