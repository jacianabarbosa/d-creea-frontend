/*
 * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 *
 */
import { Directive, Inject, Input, Renderer2, TemplateRef, ViewContainerRef, EventEmitter, } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { ClrPopoverToggleService } from './providers/popover-toggle.service';
import { ClrPopoverEventsService } from './providers/popover-events.service';
import { ClrPopoverPositionService } from './providers/popover-position.service';
import { debounceTime } from 'rxjs/operators';
// https://github.com/angular/angular/issues/20351#issuecomment-344009887
/** @dynamic */
export class ClrPopoverContent {
    constructor(document, container, template, renderer, smartPositionService, smartEventsService, smartOpenService) {
        this.document = document;
        this.container = container;
        this.template = template;
        this.renderer = renderer;
        this.smartPositionService = smartPositionService;
        this.smartEventsService = smartEventsService;
        this.smartOpenService = smartOpenService;
        this.subscriptions = [];
        this.shouldRealign = false;
        // Check-collector pattern:
        // In order to get accurate content height/width values, we cannot calculate alignment offsets until
        // after the projected content has stabilized.
        // As multiple check events may happen in the same rendering cycle, we need to collect all events
        // and only act after the content is really stable. Or we may get wrong intermediate positioning values.
        // We will channel subsequent content check events through this observable.
        this.checkCollector = new EventEmitter();
    }
    set open(value) {
        this.smartOpenService.open = !!value;
    }
    set contentAt(position) {
        this.smartPositionService.position = position;
    }
    set outsideClickClose(clickToClose) {
        this.smartEventsService.outsideClickClose = !!clickToClose;
    }
    set scrollToClose(scrollToClose) {
        this.smartEventsService.scrollToClose = !!scrollToClose;
    }
    ngAfterViewInit() {
        this.subscriptions.push(this.smartOpenService.openChange.subscribe(change => {
            if (change) {
                this.addContent();
            }
            else {
                this.removeContent();
            }
        }), this.smartPositionService.shouldRealign.subscribe(() => {
            this.shouldRealign = true;
            // Avoid flickering on initialization, caused by the asynchronous nature of the
            // check-collector pattern.
            if (this.view) {
                this.renderer.setStyle(this.view.rootNodes[0], 'opacity', '0');
            }
        }), 
        // Here we collect subsequent synchronously received content-check events and only take action
        // at the end of the cycle. See below for details on the check-collector pattern.
        this.checkCollector.pipe(debounceTime(0)).subscribe(() => {
            this.alignContent();
            this.shouldRealign = false;
            if (this.view) {
                this.renderer.setStyle(this.view.rootNodes[0], 'opacity', '1');
            }
        }));
    }
    ngOnDestroy() {
        this.removeContent();
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
    removeContent() {
        if (!this.view) {
            return;
        }
        this.view.rootNodes.forEach(node => this.renderer.removeChild(this.document.body, node));
        this.container.clear();
        delete this.view;
    }
    /**
     * TODO(matt): investigate why DebugElement retains a reference to the nodes and causes a memory leak.
     * A note about the use of appendChild/removeChild
     * The DebugElement is keeping a reference to the detached node and its unclear why.
     * This does warrant further investigation. But, since it doesn't happen in production mode
     * it is a low priority issue for now.
     */
    addContent() {
        // Create the view container
        this.view = this.container.createEmbeddedView(this.template);
        this.smartEventsService.contentRef = this.view.rootNodes[0]; // So we know where/what to set close focus on
        this.renderer.addClass(this.view.rootNodes[0], 'clr-popover-content');
        // Reset to the begining of the document to be available for sizing/positioning calculations.
        // If we add new content to the bottom it triggers changes in the layout that may lead to false anchor
        // coordinates values.
        this.renderer.setStyle(this.view.rootNodes[0], 'top', '0px');
        this.renderer.setStyle(this.view.rootNodes[0], 'left', '0px');
        // We need to hide it during the calculation phase, while it's not yet finally positioned.
        this.renderer.setStyle(this.view.rootNodes[0], 'opacity', '0');
        this.renderer.listen(this.view.rootNodes[0], 'click', event => {
            this.smartOpenService.openEvent = event;
        });
        this.view.rootNodes.forEach(node => {
            this.renderer.appendChild(this.document.body, node);
        });
        // Mark for realingment on the next content-check cycle.
        this.shouldRealign = true;
    }
    ngAfterContentChecked() {
        if (this.smartOpenService.open && this.view && this.shouldRealign) {
            // Channel content-check event through the check-collector
            this.checkCollector.emit();
        }
    }
    alignContent() {
        if (!this.view) {
            return;
        }
        const positionCoords = this.smartPositionService.alignContent(this.view.rootNodes[0]);
        this.renderer.setStyle(this.view.rootNodes[0], 'top', `${positionCoords.yOffset}px`);
        this.renderer.setStyle(this.view.rootNodes[0], 'left', `${positionCoords.xOffset}px`);
        this.smartOpenService.popoverAlignedEmit(this.view.rootNodes[0]);
    }
}
ClrPopoverContent.decorators = [
    { type: Directive, args: [{ selector: '[clrPopoverContent]' },] }
];
ClrPopoverContent.ctorParameters = () => [
    { type: HTMLDocument, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ViewContainerRef },
    { type: TemplateRef },
    { type: Renderer2 },
    { type: ClrPopoverPositionService },
    { type: ClrPopoverEventsService },
    { type: ClrPopoverToggleService }
];
ClrPopoverContent.propDecorators = {
    open: [{ type: Input, args: ['clrPopoverContent',] }],
    contentAt: [{ type: Input, args: ['clrPopoverContentAt',] }],
    outsideClickClose: [{ type: Input, args: ['clrPopoverContentOutsideClickToClose',] }],
    scrollToClose: [{ type: Input, args: ['clrPopoverContentScrollToClose',] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci1jb250ZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvY2xyLWFuZ3VsYXIvc3JjL3V0aWxzL3BvcG92ZXIvcG9wb3Zlci1jb250ZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7OztHQUtHO0FBQ0gsT0FBTyxFQUNMLFNBQVMsRUFFVCxNQUFNLEVBQ04sS0FBSyxFQUVMLFNBQVMsRUFDVCxXQUFXLEVBQ1gsZ0JBQWdCLEVBRWhCLFlBQVksR0FDYixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFHM0MsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFDN0UsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFDN0UsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFFakYsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTlDLHlFQUF5RTtBQUN6RSxlQUFlO0FBRWYsTUFBTSxPQUFPLGlCQUFpQjtJQXdCNUIsWUFDNEIsUUFBc0IsRUFDeEMsU0FBMkIsRUFDM0IsUUFBMEIsRUFDMUIsUUFBbUIsRUFDbkIsb0JBQStDLEVBQy9DLGtCQUEyQyxFQUMzQyxnQkFBeUM7UUFOdkIsYUFBUSxHQUFSLFFBQVEsQ0FBYztRQUN4QyxjQUFTLEdBQVQsU0FBUyxDQUFrQjtRQUMzQixhQUFRLEdBQVIsUUFBUSxDQUFrQjtRQUMxQixhQUFRLEdBQVIsUUFBUSxDQUFXO1FBQ25CLHlCQUFvQixHQUFwQixvQkFBb0IsQ0FBMkI7UUFDL0MsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUF5QjtRQUMzQyxxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQXlCO1FBN0IzQyxrQkFBYSxHQUFtQixFQUFFLENBQUM7UUF3R25DLGtCQUFhLEdBQUcsS0FBSyxD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QVksdUJBQS9DLE1BQU0sU0FBQyxRQUFRO1lBekNsQixnQkFBZ0I7WUFEaEIsV0FBVztZQURYLFNBQVM7WUFXRix5QkFBeUI7WUFEekIsdUJBQXVCO1lBRHZCLHVCQUF1Qjs7O21CQWE3QixLQUFLLFNBQUMsbUJBQW1CO3dCQUt6QixLQUFLLFNBQUMscUJBQXFCO2dDQUszQixLQUFLLFNBQUMsc0NBQXNDOzRCQUs1QyxLQUFLLFNBQUMsZ0NBQWdDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDIwIFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqXG4gKi9cbmltcG9ydCB7XG4gIERpcmVjdGl2ZSxcbiAgRW1iZWRkZWRWaWV3UmVmLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIFJlbmRlcmVyMixcbiAgVGVtcGxhdGVSZWYsXG4gIFZpZXdDb250YWluZXJSZWYsXG4gIEFmdGVyQ29udGVudENoZWNrZWQsXG4gIEV2ZW50RW1pdHRlcixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgQ2xyUG9wb3ZlclRvZ2dsZVNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9wb3BvdmVyLXRvZ2dsZS5zZXJ2aWNlJztcbmltcG9ydCB7IENsclBvcG92ZXJFdmVudHNTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvcG9wb3Zlci1ldmVudHMuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJQb3BvdmVyUG9zaXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvcG9wb3Zlci1wb3NpdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IENsclBvcG92ZXJQb3NpdGlvbiB9IGZyb20gJy4vaW50ZXJmYWNlcy9wb3BvdmVyLXBvc2l0aW9uLmludGVyZmFjZSc7XG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzIwMzUxI2lzc3VlY29tbWVudC0zNDQwMDk4ODdcbi8qKiBAZHluYW1pYyAqL1xuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsclBvcG92ZXJDb250ZW50XScgfSlcbmV4cG9ydCBjbGFzcyBDbHJQb3BvdmVyQ29udGVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudENoZWNrZWQsIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgdmlldzogRW1iZWRkZWRWaWV3UmVmPHZvaWQ+O1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgQElucHV0KCdjbHJQb3BvdmVyQ29udGVudCcpXG4gIHB1YmxpYyBzZXQgb3Blbih2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuc21hcnRPcGVuU2VydmljZS5vcGVuID0gISF2YWx1ZTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyUG9wb3ZlckNvbnRlbnRBdCcpXG4gIHNldCBjb250ZW50QXQocG9zaXRpb246IENsclBvcG92ZXJQb3NpdGlvbikge1xuICAgIHRoaXMuc21hcnRQb3NpdGlvblNlcnZpY2UucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyUG9wb3ZlckNvbnRlbnRPdXRzaWRlQ2xpY2tUb0Nsb3NlJylcbiAgc2V0IG91dHNpZGVDbGlja0Nsb3NlKGNsaWNrVG9DbG9zZTogYm9vbGVhbikge1xuICAgIHRoaXMuc21hcnRFdmVudHNTZXJ2aWNlLm91dHNpZGVDbGlja0Nsb3NlID0gISFjbGlja1RvQ2xvc2U7XG4gIH1cblxuICBASW5wdXQoJ2NsclBvcG92ZXJDb250ZW50U2Nyb2xsVG9DbG9zZScpXG4gIHNldCBzY3JvbGxUb0Nsb3NlKHNjcm9sbFRvQ2xvc2U6IGJvb2xlYW4pIHtcbiAgICB0aGlzLnNtYXJ0RXZlbnRzU2VydmljZS5zY3JvbGxUb0Nsb3NlID0gISFzY3JvbGxUb0Nsb3NlO1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBkb2N1bWVudDogSFRNTERvY3VtZW50LFxuICAgIHByaXZhdGUgY29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIHByaXZhdGUgdGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4sXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIHByaXZhdGUgc21hcnRQb3NpdGlvblNlcnZpY2U6IENsclBvcG92ZXJQb3NpdGlvblNlcnZpY2UsXG4gICAgcHJpdmF0ZSBzbWFydEV2ZW50c1NlcnZpY2U6IENsclBvcG92ZXJFdmVudHNTZXJ2aWNlLFxuICAgIHByaXZhdGUgc21hcnRPcGVuU2VydmljZTogQ2xyUG9wb3ZlclRvZ2dsZVNlcnZpY2VcbiAgKSB7fVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuc21hcnRPcGVuU2VydmljZS5vcGVuQ2hhbmdlLnN1YnNjcmliZShjaGFuZ2UgPT4ge1xuICAgICAgICBpZiAoY2hhbmdlKSB7XG4gICAgICAgICAgdGhpcy5hZGRDb250ZW50KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVDb250ZW50KCk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgdGhpcy5zbWFydFBvc2l0aW9uU2VydmljZS5zaG91bGRSZWFsaWduLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuc2hvdWxkUmVhbGlnbiA9IHRydWU7XG4gICAgICAgIC8vIEF2b2lkIGZsaWNrZXJpbmcgb24gaW5pdGlhbGl6YXRpb24sIGNhdXNlZCBieSB0aGUgYXN5bmNocm9ub3VzIG5hdHVyZSBvZiB0aGVcbiAgICAgICAgLy8gY2hlY2stY29sbGVjdG9yIHBhdHRlcm4uXG4gICAgICAgIGlmICh0aGlzLnZpZXcpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMudmlldy5yb290Tm9kZXNbMF0sICdvcGFjaXR5JywgJzAnKTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICAvLyBIZXJlIHdlIGNvbGxlY3Qgc3Vic2VxdWVudCBzeW5jaHJvbm91c2x5IHJlY2VpdmVkIGNvbnRlbnQtY2hlY2sgZXZlbnRzIGFuZCBvbmx5IHRha2UgYWN0aW9uXG4gICAgICAvLyBhdCB0aGUgZW5kIG9mIHRoZSBjeWNsZS4gU2VlIGJlbG93IGZvciBkZXRhaWxzIG9uIHRoZSBjaGVjay1jb2xsZWN0b3IgcGF0dGVybi5cbiAgICAgIHRoaXMuY2hlY2tDb2xsZWN0b3IucGlwZShkZWJvdW5jZVRpbWUoMCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuYWxpZ25Db250ZW50KCk7XG4gICAgICAgIHRoaXMuc2hvdWxkUmVhbGlnbiA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy52aWV3KSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLnZpZXcucm9vdE5vZGVzWzBdLCAnb3BhY2l0eScsICcxJyk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMucmVtb3ZlQ29udGVudCgpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cblxuICBwcml2YXRlIHJlbW92ZUNvbnRlbnQoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnZpZXcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy52aWV3LnJvb3ROb2Rlcy5mb3JFYWNoKG5vZGUgPT4gdGhpcy5yZW5kZXJlci5yZW1vdmVDaGlsZCh0aGlzLmRvY3VtZW50LmJvZHksIG5vZGUpKTtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGVhcigpO1xuICAgIGRlbGV0ZSB0aGlzLnZpZXc7XG4gIH1cblxuICAvKipcbiAgICogVE9ETyhtYXR0KTogaW52ZXN0aWdhdGUgd2h5IERlYnVnRWxlbWVudCByZXRhaW5zIGEgcmVmZXJlbmNlIHRvIHRoZSBub2RlcyBhbmQgY2F1c2VzIGEgbWVtb3J5IGxlYWsuXG4gICAqIEEgbm90ZSBhYm91dCB0aGUgdXNlIG9mIGFwcGVuZENoaWxkL3JlbW92ZUNoaWxkXG4gICAqIFRoZSBEZWJ1Z0VsZW1lbnQgaXMga2VlcGluZyBhIHJlZmVyZW5jZSB0byB0aGUgZGV0YWNoZWQgbm9kZSBhbmQgaXRzIHVuY2xlYXIgd2h5LlxuICAgKiBUaGlzIGRvZXMgd2FycmFudCBmdXJ0aGVyIGludmVzdGlnYXRpb24uIEJ1dCwgc2luY2UgaXQgZG9lc24ndCBoYXBwZW4gaW4gcHJvZHVjdGlvbiBtb2RlXG4gICAqIGl0IGlzIGEgbG93IHByaW9yaXR5IGlzc3VlIGZvciBub3cuXG4gICAqL1xuICBwcml2YXRlIGFkZENvbnRlbnQoKSB7XG4gICAgLy8gQ3JlYXRlIHRoZSB2aWV3IGNvbnRhaW5lclxuICAgIHRoaXMudmlldyA9IHRoaXMuY29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLnRlbXBsYXRlKTtcbiAgICB0aGlzLnNtYXJ0RXZlbnRzU2VydmljZS5jb250ZW50UmVmID0gdGhpcy52aWV3LnJvb3ROb2Rlc1swXTsgLy8gU28gd2Uga25vdyB3aGVyZS93aGF0IHRvIHNldCBjbG9zZSBmb2N1cyBvblxuICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy52aWV3LnJvb3ROb2Rlc1swXSwgJ2Nsci1wb3BvdmVyLWNvbnRlbnQnKTtcbiAgICAvLyBSZXNldCB0byB0aGUgYmVnaW5pbmcgb2YgdGhlIGRvY3VtZW50IHRvIGJlIGF2YWlsYWJsZSBmb3Igc2l6aW5nL3Bvc2l0aW9uaW5nIGNhbGN1bGF0aW9ucy5cbiAgICAvLyBJZiB3ZSBhZGQgbmV3IGNvbnRlbnQgdG8gdGhlIGJvdHRvbSBpdCB0cmlnZ2VycyBjaGFuZ2VzIGluIHRoZSBsYXlvdXQgdGhhdCBtYXkgbGVhZCB0byBmYWxzZSBhbmNob3JcbiAgICAvLyBjb29yZGluYXRlcyB2YWx1ZXMuXG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLnZpZXcucm9vdE5vZGVzWzBdLCAndG9wJywgJzBweCcpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy52aWV3LnJvb3ROb2Rlc1swXSwgJ2xlZnQnLCAnMHB4Jyk7XG4gICAgLy8gV2UgbmVlZCB0byBoaWRlIGl0IGR1cmluZyB0aGUgY2FsY3VsYXRpb24gcGhhc2UsIHdoaWxlIGl0J3Mgbm90IHlldCBmaW5hbGx5IHBvc2l0aW9uZWQuXG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLnZpZXcucm9vdE5vZGVzWzBdLCAnb3BhY2l0eScsICcwJyk7XG4gICAgdGhpcy5yZW5kZXJlci5saXN0ZW4odGhpcy52aWV3LnJvb3ROb2Rlc1swXSwgJ2NsaWNrJywgZXZlbnQgPT4ge1xuICAgICAgdGhpcy5zbWFydE9wZW5TZXJ2aWNlLm9wZW5FdmVudCA9IGV2ZW50O1xuICAgIH0pO1xuICAgIHRoaXMudmlldy5yb290Tm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIHRoaXMucmVuZGVyZXIuYXBwZW5kQ2hpbGQodGhpcy5kb2N1bWVudC5ib2R5LCBub2RlKTtcbiAgICB9KTtcbiAgICAvLyBNYXJrIGZvciByZWFsaW5nbWVudCBvbiB0aGUgbmV4dCBjb250ZW50LWNoZWNrIGN5Y2xlLlxuICAgIHRoaXMuc2hvdWxkUmVhbGlnbiA9IHRydWU7XG4gIH1cblxuICBwcml2YXRlIHNob3VsZFJlYWxpZ24gPSBmYWxzZTtcblxuICAvLyBDaGVjay1jb2xsZWN0b3IgcGF0dGVybjpcbiAgLy8gSW4gb3JkZXIgdG8gZ2V0IGFjY3VyYXRlIGNvbnRlbnQgaGVpZ2h0L3dpZHRoIHZhbHVlcywgd2UgY2Fubm90IGNhbGN1bGF0ZSBhbGlnbm1lbnQgb2Zmc2V0cyB1bnRpbFxuICAvLyBhZnRlciB0aGUgcHJvamVjdGVkIGNvbnRlbnQgaGFzIHN0YWJpbGl6ZWQuXG4gIC8vIEFzIG11bHRpcGxlIGNoZWNrIGV2ZW50cyBtYXkgaGFwcGVuIGluIHRoZSBzYW1lIHJlbmRlcmluZyBjeWNsZSwgd2UgbmVlZCB0byBjb2xsZWN0IGFsbCBldmVudHNcbiAgLy8gYW5kIG9ubHkgYWN0IGFmdGVyIHRoZSBjb250ZW50IGlzIHJlYWxseSBzdGFibGUuIE9yIHdlIG1heSBnZXQgd3JvbmcgaW50ZXJtZWRpYXRlIHBvc2l0aW9uaW5nIHZhbHVlcy5cbiAgLy8gV2Ugd2lsbCBjaGFubmVsIHN1YnNlcXVlbnQgY29udGVudCBjaGVjayBldmVudHMgdGhyb3VnaCB0aGlzIG9ic2VydmFibGUuXG4gIHByaXZhdGUgY2hlY2tDb2xsZWN0b3I6IEV2ZW50RW1pdHRlcjx2b2lkPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICBuZ0FmdGVyQ29udGVudENoZWNrZWQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc21hcnRPcGVuU2VydmljZS5vcGVuICYmIHRoaXMudmlldyAmJiB0aGlzLnNob3VsZFJlYWxpZ24pIHtcbiAgICAgIC8vIENoYW5uZWwgY29udGVudC1jaGVjayBldmVudCB0aHJvdWdoIHRoZSBjaGVjay1jb2xsZWN0b3JcbiAgICAgIHRoaXMuY2hlY2tDb2xsZWN0b3IuZW1pdCgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYWxpZ25Db250ZW50KCkge1xuICAgIGlmICghdGhpcy52aWV3KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uQ29vcmRzID0gdGhpcy5zbWFydFBvc2l0aW9uU2VydmljZS5hbGlnbkNvbnRlbnQodGhpcy52aWV3LnJvb3ROb2Rlc1swXSk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLnZpZXcucm9vdE5vZGVzWzBdLCAndG9wJywgYCR7cG9zaXRpb25Db29yZHMueU9mZnNldH1weGApO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy52aWV3LnJvb3ROb2Rlc1swXSwgJ2xlZnQnLCBgJHtwb3NpdGlvbkNvb3Jkcy54T2Zmc2V0fXB4YCk7XG4gICAgdGhpcy5zbWFydE9wZW5TZXJ2aWNlLnBvcG92ZXJBbGlnbmVkRW1pdCh0aGlzLnZpZXcucm9vdE5vZGVzWzBdKTtcbiAgfVxufVxuIl19