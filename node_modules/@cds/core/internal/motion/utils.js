/*
 * Copyright (c) 2016-2021 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { AnimationStatus, CLARITY_MOTION_ENTER_LEAVE_PROPERTY, CLARITY_MOTION_FALLBACK_DURATION_IN_MS, CLARITY_MOTION_FALLBACK_EASING, CLARITY_MOTION_REVERSE_ANIMATION_LABEL, CLARITY_MOTION_REVERSE_ANIMATION_SUFFIX, } from './interfaces.js';
import { LogService } from '../services/log.service.js';
import { ClarityMotion } from './motion.service.js';
import clone from 'ramda/es/clone.js';
import { getCssPropertyValue, isCssPropertyName } from '../utils/css.js';
import { isPrefixedBy, isSuffixedBy, getNumericValueFromCssSecondsStyleValue, removePrefix } from '../utils/string.js';
import { queryChildFromLightOrShadowDom } from '../utils/dom.js';
import { allPropertiesPass, getMillisecondsFromSeconds } from '../utils/identity.js';
/**
 * runPropertyAnimations() is a utility function called by the @animate(). It is a single point of entry
 * to execute the property-driven animations found in components like the accordion and overlay.
 *
 * Other utilities here are exported to break up the unit tests covering the animation/motion
 * library. While they could be called or used in isolation, it is not recommended for most use cases.
 *
 * runPropertyAnimations returns a boolean so that we know if it ran successfully or not. This is
 * mostly to make testing the function easier.
 *
 * @internal
 */
export async function runPropertyAnimations(props, hostEl) {
    if (!hostEl._animations) {
        LogService.warn(`${hostEl.tagName.toLocaleLowerCase()} is trying to animate but no animations are defined.`);
        return false;
    }
    // this runs through animations for each property sequentially
    // animations passed into getPropertyAnimations are the Property-Driven Animations
    // passed into the @animate decorator
    // { hidden: { true: 'cds-modal-enter-reverse', false: 'enter' }, status: { error: 'cds-component-shake' } }
    // getPropertyAnimations transforms the @animate decorator config into an array of
    // tuples so they are easier to work with.
    // ['hidden', { true: 'cds-modal-enter-reverse', false: 'enter' }], ['status', { error: 'cds-component-shake' }]
    // * inactive animations are filtered out
    const propertyAnimations = getPropertyAnimations(hostEl._animations, props);
    const animationsRan = await Promise.all(propertyAnimations.map((propNameAnimationTuple) => {
        const [propname, propertyAnimationsByValue] = propNameAnimationTuple;
        if (props.get(propname) === hostEl[propname]) {
            // a weird/unlikely state where an update is sent but the property value didn't actually change
            return false;
        }
        // gets animations to run based on the property's value
        const animatedPropertyValueAsString = propertyAnimationsByValue[hostEl[propname].toString()];
        const cdsMotionValue = hostEl.cdsMotion;
        // looping through each tuple value in order, getAnimationConfigForPropertyValue()
        // returns a tuple with the animation name from Clarity Motion and the TargetedAnimation
        // config (also returned from the Clarity Motion service)
        // ['enter-reverse', [ { target: '.private-host', animation: [ { opacity: 0 }, { opacity: 1 } ], options: { duration: 300 }}]
        const [motionName, returnedMotion] = getAnimationConfigForPropertyValue(animatedPropertyValueAsString, getInlineOverride(cdsMotionValue, propname, hostEl[propname].toString()));
        let motionForMyValue = clone(returnedMotion); // have to jump through this hoop to keep typescript happy
        // jumps out if there are no animation routines
        if (motionForMyValue.length < 1) {
            return false;
        }
        motionForMyValue = setAnimationConfigOptions(motionName, motionForMyValue, hostEl);
        // loops through animation config and runs them; assigns the promises to an array we can Promise.all() at the end
        const animations = getAnimationPromiseInstructions(animatedPropertyValueAsString, motionForMyValue, hostEl);
        return Promise.all(animations).then(() => {
            resolveAnimationEndStatus(animatedPropertyValueAsString, hostEl);
            return true;
        });
    }))
        .then(result => {
        return result.indexOf(true) > -1;
    })
        .catch(() => {
        return false;
    });
    return animationsRan;
}
// --- CONTROL FLOW UTILS ---
export function setAnimationStartStatus(animatedPropertyValueAsString, hostEl) {
    // accesses and manipulates the private animation status attr;
    if (hostEl.getAttribute('_cds-animation-status') !== AnimationStatus.active) {
        hostEl.setAttribute('_cds-animation-status', AnimationStatus.active);
        // this is here so we only emit the start event once, right when the whole animation starts...
        hostEl.cdsMotionChange.emit(`${animatedPropertyValueAsString} animation ${AnimationStatus.start}`);
    }
}
export function resolveAnimationEndStatus(animatedPropertyValueAsString, hostEl) {
    // sets super secret animation attr back to 'ready'
    hostEl.setAttribute('_cds-animation-status', AnimationStatus.ready); // A
    // emits the name of the animation and that it ended
    hostEl.cdsMotionChange.emit(`${animatedPropertyValueAsString} animation ${AnimationStatus.end}`); // A
}
export function setAnimationConfigOptions(motionName, motionForMyValue, hostEl) {
    const cdsMotionValue = hostEl.cdsMotion;
    const animationsAreTurnedOff = !cdsMotionValue || cdsMotionValue === 'off';
    // the following set of functions – reverseAnimationConfig(), zeroOutAnimationConfig(),
    // setAnimationDuration(), setAnimationEasing() – modify the "options" portion of the animation routine
    // in the tuple above that is returned from getAnimationConfigForPropertyValue
    if (animationIsReversed(motionName)) {
        motionForMyValue = reverseAnimationConfig(motionForMyValue);
    }
    if (animationsAreTurnedOff) {
        // cdsMotion is turned off, so zero out the duration
        motionForMyValue = zeroOutAnimationConfig(motionForMyValue);
    }
    else {
        // sets duration and easing based on CSS properties, passed values, or a global fallback
        motionForMyValue = setAnimationDuration(motionForMyValue, hostEl);
        motionForMyValue = setAnimationEasing(motionForMyValue, hostEl);
    }
    return motionForMyValue;
}
export function getAnimationPromiseInstructions(animatedPropertyValueAsString, motionConfigs, hostEl) {
    return motionConfigs
        .filter(config => !config.onlyIf || allPropertiesPass(hostEl, config.onlyIf))
        .map(config => {
        setAnimationStartStatus(animatedPropertyValueAsString, hostEl);
        return new Promise(resolve => {
            const animationPlayer = getAnimationTarget(hostEl, config.target).animate(getAnimationKeyframesOrPropertyIndexedFrames(config.animation, hostEl), config.options || {});
            const listener = () => {
                resolve('animation finished');
                animationPlayer.removeEventListener('finish', listener);
            };
            animationPlayer.addEventListener('finish', listener);
        });
    });
}
export function getAnimationTarget(hostEl, targetSelector) {
    return queryChildFromLightOrShadowDom(hostEl, targetSelector) || hostEl;
}
export function getAnimationKeyframesOrPropertyIndexedFrames(animationConfig, hostEl) {
    return !Array.isArray(animationConfig) ? animationConfig : sizeDimensionKeyframes(animationConfig, hostEl);
}
// --- REVERSING UTILS ---
// string -> boolean
export function animationIsReversed(nameOfAnimation) {
    return isSuffixedBy(nameOfAnimation, CLARITY_MOTION_REVERSE_ANIMATION_SUFFIX);
}
// { target: '.my-selector', animation: [<keyframes>], options: { duration: 500 }} ->
// { target: '.my-selector', animation: [<keyframes>], options: { duration: 500, direction: 'reverse' }}
export function reverseAnimationConfig(config) {
    return config.map((anim) => {
        if (anim.options) {
            anim.options.direction = CLARITY_MOTION_REVERSE_ANIMATION_LABEL;
        }
        else {
            anim.options = { direction: CLARITY_MOTION_REVERSE_ANIMATION_LABEL };
        }
        return anim;
    });
}
// 'my-animation' -> 'my-animation-reverse'
export function reverseAnimation(animationName) {
    return [animationName, '-', CLARITY_MOTION_REVERSE_ANIMATION_LABEL].join('');
}
// --- ANIMATION CONFIG RETRIEVAL ---
// returns an animation name from a stringified @animate decorator config passed into the
// cds-motion attr. looks it up by property first and value second. returns empty string
// if no animation name matches the property and property value.
export function getInlineOverride(cdsMotionValue, propName, propValue) {
    if (!cdsMotionValue || !propName || typeof propValue === 'undefined') {
        return '';
    }
    if (cdsMotionValue === 'on' || cdsMotionValue === 'off') {
        return '';
    }
    let inlineOverride;
    try {
        inlineOverride = JSON.parse(cdsMotionValue);
    }
    catch (e) {
        return '';
    }
    const overrideValue = inlineOverride[propName] && inlineOverride[propName][propValue];
    return overrideValue ? overrideValue : '';
}
// 'i-am-reverse' -> 'i-am'
export function extractAnimationNameIfReversed(name) {
    return animationIsReversed(name) ? name.slice(0, -1 * CLARITY_MOTION_REVERSE_ANIMATION_SUFFIX.length) : name;
}
// if the name retrieved from the cds-motion config is present in Clarity Motion, it is returned
export function getAnimationFromOverrideOrDecorator(decoratorValue, overrideValue) {
    if (!overrideValue) {
        return decoratorValue;
    }
    return ClarityMotion.has(extractAnimationNameIfReversed(overrideValue)) ? overrideValue : decoratorValue;
}
// ('animation-name') -> ['animation-name', [ { target: '.an-element', animation: [<keyframes>], options: { ... }}]];
// ('animation-name', 'name-retrieved-from-cds-motion-config') ->
// ['name-retrieved-from-cds-motion-config', [ { target: ..., animation: [<keyframes>], options: { ... }}]];
export function getAnimationConfigForPropertyValue(nameOfAnimationFromObject, cdsMotionOverride) {
    const nameOfAnimation = getAnimationFromOverrideOrDecorator(nameOfAnimationFromObject, cdsMotionOverride);
    return [nameOfAnimation, clone(ClarityMotion.get(extractAnimationNameIfReversed(nameOfAnimation)))];
}
// --- SETTING ANIMATION CONFIG VALUES ---
export function setAnimationDuration(config, hostEl) {
    return setAnimationProperty('duration', hostEl, config, CLARITY_MOTION_FALLBACK_DURATION_IN_MS, (val) => {
        return getMillisecondsFromSeconds(getNumericValueFromCssSecondsStyleValue(val));
    });
}
export function setAnimationEasing(config, hostEl) {
    return setAnimationProperty('easing', hostEl, config, CLARITY_MOTION_FALLBACK_EASING);
}
export function zeroOutAnimationConfig(config) {
    return config.map(anim => {
        if (anim.options) {
            anim.options.duration = 0;
            anim.options.easing = CLARITY_MOTION_FALLBACK_EASING;
        }
        else {
            anim.options = { duration: 0, easing: CLARITY_MOTION_FALLBACK_EASING };
        }
        return anim;
    });
}
export function setAnimationProperty(propertyName, hostEl, config, staticFallback, valueConverter) {
    return config.map((anim) => {
        if (anim.options) {
            if (!anim.options[propertyName]) {
                anim.options[propertyName] = staticFallback;
            }
            else if (isCssPropertyName(anim.options[propertyName])) {
                const myConfigOption = anim.options[propertyName];
                let valFromProperty = getCssPropertyValue(myConfigOption, hostEl);
                if (!valFromProperty) {
                    valFromProperty = staticFallback;
                }
                else if (valueConverter) {
                    valFromProperty = valueConverter(valFromProperty);
                }
                anim.options[propertyName] = valFromProperty;
            }
            // else fallthrough not required because option is already set to intended value
        }
        else {
            const newConfigOptions = {};
            newConfigOptions[propertyName] = staticFallback;
            anim.options = newConfigOptions;
        }
        return anim;
    });
}
// -- TRANSFORM PROPERTY-DRIVEN ANIMATION OBJECTS TO ANIMATION CONFIG OBJECTS ---
export function sizeDimensionKeyframes(animationKeyframes, hostEl) {
    if (!Array.isArray(animationKeyframes)) {
        return animationKeyframes;
    }
    return animationKeyframes.map((kf) => {
        var _a, _b, _c, _d;
        if ((kf === null || kf === void 0 ? void 0 : kf.hasOwnProperty('height')) && isPrefixedBy(((_a = kf === null || kf === void 0 ? void 0 : kf.height) === null || _a === void 0 ? void 0 : _a.toString()) || '', 'from:')) {
            const selector = removePrefix(((_b = kf === null || kf === void 0 ? void 0 : kf.height) === null || _b === void 0 ? void 0 : _b.toString()) || '', 'from:');
            const measureTarget = queryChildFromLightOrShadowDom(hostEl, selector) || null;
            kf.height = !measureTarget ? 'auto' : measureTarget.getBoundingClientRect().height + 'px';
        }
        if ((kf === null || kf === void 0 ? void 0 : kf.hasOwnProperty('width')) && isPrefixedBy(((_c = kf === null || kf === void 0 ? void 0 : kf.width) === null || _c === void 0 ? void 0 : _c.toString()) || '', 'from:')) {
            const selector = removePrefix(((_d = kf === null || kf === void 0 ? void 0 : kf.width) === null || _d === void 0 ? void 0 : _d.toString()) || '', 'from:');
            const measureTarget = queryChildFromLightOrShadowDom(hostEl, selector) || null;
            kf.width = !measureTarget ? 'auto' : measureTarget.getBoundingClientRect().width + 'px';
        }
        return kf;
    });
}
export function filterAnimationsByUpdatedProperties(animations, updatingProps) {
    if (animations === null || animations === undefined || animations === {}) {
        return null;
    }
    let objectIsEmpty = true;
    const returnObject = {};
    Object.getOwnPropertyNames(animations).forEach((prop) => {
        if (updatingProps.has(prop)) {
            returnObject[prop] = clone(animations[prop]);
            objectIsEmpty = false;
        }
    });
    return objectIsEmpty ? null : returnObject;
}
export function flattenAndSortAnimations(hiddenAndNotAnimationTuple, isHiding) {
    if (hiddenAndNotAnimationTuple === null || hiddenAndNotAnimationTuple === undefined) {
        return [];
    }
    const [hiddenAnimations, otherAnimations] = hiddenAndNotAnimationTuple;
    if (hiddenAnimations.length > 0) {
        if (isHiding) {
            // hiding hostEl
            return [].concat(otherAnimations, hiddenAnimations);
        }
        else {
            // showing hostEl
            return [].concat(hiddenAnimations, otherAnimations);
        }
    }
    else {
        return otherAnimations;
    }
}
export function getHidingAndNonHidingPropertyAnimations(animations) {
    const hiddenAnimations = [];
    const otherAnimations = [];
    Object.getOwnPropertyNames(animations || {}).forEach((prop) => {
        const animationTuple = [prop, clone(animations[prop])];
        if (prop === CLARITY_MOTION_ENTER_LEAVE_PROPERTY) {
            hiddenAnimations.push(animationTuple);
        }
        else {
            otherAnimations.push(animationTuple);
        }
    });
    return [hiddenAnimations, otherAnimations];
}
export function getPropertyAnimations(animations, updatingProps) {
    const activeAnimations = filterAnimationsByUpdatedProperties(animations || {}, updatingProps);
    if (activeAnimations === null) {
        return [];
    }
    const hidingAndOtherAnimationsAsTuple = getHidingAndNonHidingPropertyAnimations(activeAnimations);
    const isHiding = updatingProps.get(CLARITY_MOTION_ENTER_LEAVE_PROPERTY);
    return flattenAndSortAnimations(hidingAndOtherAnimationsAsTuple, isHiding);
}
//# sourceMappingURL=utils.js.map