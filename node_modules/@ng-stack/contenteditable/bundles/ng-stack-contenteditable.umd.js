(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/forms'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('@ng-stack/contenteditable', ['exports', '@angular/core', '@angular/forms', '@angular/common'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['ng-stack'] = global['ng-stack'] || {}, global['ng-stack'].contenteditable = {}), global.ng.core, global.ng.forms, global.ng.common));
}(this, (function (exports, core, forms, common) { 'use strict';

    /** @dynamic */
    var ContenteditableDirective = /** @class */ (function () {
        function ContenteditableDirective(elementRef, renderer, unformattedPaste, document) {
            this.elementRef = elementRef;
            this.renderer = renderer;
            this.unformattedPaste = unformattedPaste;
            this.document = document;
            this.propValueAccessor = 'textContent';
            this.contenteditable = true;
        }
        ContenteditableDirective.prototype.callOnChange = function () {
            if (typeof this.onChange == 'function') {
                this.onChange(this.elementRef.nativeElement[this.propValueAccessor]);
            }
        };
        ContenteditableDirective.prototype.callOnTouched = function () {
            if (typeof this.onTouched == 'function') {
                this.onTouched();
            }
        };
        /**
         * Writes a new value to the element.
         * This method will be called by the forms API to write
         * to the view when programmatic (model -> view) changes are requested.
         *
         * See: [ControlValueAccessor](https://angular.io/api/forms/ControlValueAccessor#members)
         */
        ContenteditableDirective.prototype.writeValue = function (value) {
            var normalizedValue = value == null ? '' : value;
            this.renderer.setProperty(this.elementRef.nativeElement, this.propValueAccessor, normalizedValue);
        };
        /**
         * Registers a callback function that should be called when
         * the control's value changes in the UI.
         *
         * This is called by the forms API on initialization so it can update
         * the form model when values propagate from the view (view -> model).
         */
        ContenteditableDirective.prototype.registerOnChange = function (fn) {
            this.onChange = fn;
        };
        /**
         * Registers a callback function that should be called when the control receives a blur event.
         * This is called by the forms API on initialization so it can update the form model on blur.
         */
        ContenteditableDirective.prototype.registerOnTouched = function (fn) {
            this.onTouched = fn;
        };
        /**
         * This function is called by the forms API when the control status changes to or from "DISABLED".
         * Depending on the value, it should enable or disable the appropriate DOM element.
         */
        ContenteditableDirective.prototype.setDisabledState = function (isDisabled) {
            if (isDisabled) {
                this.renderer.setAttribute(this.elementRef.nativeElement, 'disabled', 'true');
                this.removeDisabledState = this.renderer.listen(this.elementRef.nativeElement, 'keydown', this.listenerDisabledState);
            }
            else {
                if (this.removeDisabledState) {
                    this.renderer.removeAttribute(this.elementRef.nativeElement, 'disabled');
                    this.removeDisabledState();
                }
            }
        };
        ContenteditableDirective.prototype.preventFormatedPaste = function (event) {
            if (this.unformattedPaste === null || this.unformattedPaste == 'false' || !this.document.execCommand) {
                return;
            }
            event.preventDefault();
            var clipboardData = event.clipboardData;
            var text = clipboardData.getData('text/plain') || clipboardData.getData('text');
            this.document.execCommand('insertText', false, text);
        };
        ContenteditableDirective.prototype.listenerDisabledState = function (e) {
            e.preventDefault();
        };
        return ContenteditableDirective;
    }());
    ContenteditableDirective.decorators = [
        { type: core.Directive, args: [{
                    // tslint:disable-next-line:directive-selector
                    selector: '[contenteditable][formControlName],[contenteditable][formControl],[contenteditable][ngModel]',
                    providers: [{ provide: forms.NG_VALUE_ACCESSOR, useExisting: core.forwardRef(function () { return ContenteditableDirective; }), multi: true }],
                },] }
    ];
    ContenteditableDirective.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Renderer2 },
        { type: String, decorators: [{ type: core.Attribute, args: ['unformattedPaste',] }] },
        { type: Document, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
    ]; };
    ContenteditableDirective.propDecorators = {
        propValueAccessor: [{ type: core.Input }],
        contenteditable: [{ type: core.HostBinding, args: ['attr.contenteditable',] }, { type: core.Input }],
        callOnChange: [{ type: core.HostListener, args: ['input',] }],
        callOnTouched: [{ type: core.HostListener, args: ['blur',] }],
        preventFormatedPaste: [{ type: core.HostListener, args: ['paste', ['$event'],] }]
    };

    var ContenteditableModule = /** @class */ (function () {
        function ContenteditableModule() {
        }
        return ContenteditableModule;
    }());
    ContenteditableModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [ContenteditableDirective],
                    exports: [ContenteditableDirective],
                },] }
    ];

    /*
     * Public API Surface of contenteditable
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.ContenteditableDirective = ContenteditableDirective;
    exports.ContenteditableModule = ContenteditableModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ng-stack-contenteditable.umd.js.map
