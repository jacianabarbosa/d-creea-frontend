import { Directive, forwardRef, ElementRef, Renderer2, Attribute, Inject, Input, HostBinding, HostListener, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { DOCUMENT } from '@angular/common';

/** @dynamic */
import * as ɵngcc0 from '@angular/core';
class ContenteditableDirective {
    constructor(elementRef, renderer, unformattedPaste, document) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.unformattedPaste = unformattedPaste;
        this.document = document;
        this.propValueAccessor = 'textContent';
        this.contenteditable = true;
    }
    callOnChange() {
        if (typeof this.onChange == 'function') {
            this.onChange(this.elementRef.nativeElement[this.propValueAccessor]);
        }
    }
    callOnTouched() {
        if (typeof this.onTouched == 'function') {
            this.onTouched();
        }
    }
    /**
     * Writes a new value to the element.
     * This method will be called by the forms API to write
     * to the view when programmatic (model -> view) changes are requested.
     *
     * See: [ControlValueAccessor](https://angular.io/api/forms/ControlValueAccessor#members)
     */
    writeValue(value) {
        const normalizedValue = value == null ? '' : value;
        this.renderer.setProperty(this.elementRef.nativeElement, this.propValueAccessor, normalizedValue);
    }
    /**
     * Registers a callback function that should be called when
     * the control's value changes in the UI.
     *
     * This is called by the forms API on initialization so it can update
     * the form model when values propagate from the view (view -> model).
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * Registers a callback function that should be called when the control receives a blur event.
     * This is called by the forms API on initialization so it can update the form model on blur.
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * This function is called by the forms API when the control status changes to or from "DISABLED".
     * Depending on the value, it should enable or disable the appropriate DOM element.
     */
    setDisabledState(isDisabled) {
        if (isDisabled) {
            this.renderer.setAttribute(this.elementRef.nativeElement, 'disabled', 'true');
            this.removeDisabledState = this.renderer.listen(this.elementRef.nativeElement, 'keydown', this.listenerDisabledState);
        }
        else {
            if (this.removeDisabledState) {
                this.renderer.removeAttribute(this.elementRef.nativeElement, 'disabled');
                this.removeDisabledState();
            }
        }
    }
    preventFormatedPaste(event) {
        if (this.unformattedPaste === null || this.unformattedPaste == 'false' || !this.document.execCommand) {
            return;
        }
        event.preventDefault();
        const { clipboardData } = event;
        const text = clipboardData.getData('text/plain') || clipboardData.getData('text');
        this.document.execCommand('insertText', false, text);
    }
    listenerDisabledState(e) {
        e.preventDefault();
    }
}
ContenteditableDirective.ɵfac = function ContenteditableDirective_Factory(t) { return new (t || ContenteditableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵinjectAttribute('unformattedPaste'), ɵngcc0.ɵɵdirectiveInject(DOCUMENT)); };
ContenteditableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ContenteditableDirective, selectors: [["", "contenteditable", "", "formControlName", ""], ["", "contenteditable", "", "formControl", ""], ["", "contenteditable", "", "ngModel", ""]], hostVars: 1, hostBindings: function ContenteditableDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("input", function ContenteditableDirective_input_HostBindingHandler() { return ctx.callOnChange(); })("blur", function ContenteditableDirective_blur_HostBindingHandler() { return ctx.callOnTouched(); })("paste", function ContenteditableDirective_paste_HostBindingHandler($event) { return ctx.preventFormatedPaste($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("contenteditable", ctx.contenteditable);
    } }, inputs: { propValueAccessor: "propValueAccessor", contenteditable: "contenteditable" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => ContenteditableDirective), multi: true }])] });
ContenteditableDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: String, decorators: [{ type: Attribute, args: ['unformattedPaste',] }] },
    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
ContenteditableDirective.propDecorators = {
    propValueAccessor: [{ type: Input }],
    contenteditable: [{ type: HostBinding, args: ['attr.contenteditable',] }, { type: Input }],
    callOnChange: [{ type: HostListener, args: ['input',] }],
    callOnTouched: [{ type: HostListener, args: ['blur',] }],
    preventFormatedPaste: [{ type: HostListener, args: ['paste', ['$event'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContenteditableDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: '[contenteditable][formControlName],[contenteditable][formControl],[contenteditable][ngModel]',
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => ContenteditableDirective), multi: true }]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: String, decorators: [{
                type: Attribute,
                args: ['unformattedPaste']
            }] }, { type: Document, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, { propValueAccessor: [{
            type: Input
        }], contenteditable: [{
            type: HostBinding,
            args: ['attr.contenteditable']
        }, {
            type: Input
        }], callOnChange: [{
            type: HostListener,
            args: ['input']
        }], callOnTouched: [{
            type: HostListener,
            args: ['blur']
        }], preventFormatedPaste: [{
            type: HostListener,
            args: ['paste', ['$event']]
        }] }); })();

class ContenteditableModule {
}
ContenteditableModule.ɵfac = function ContenteditableModule_Factory(t) { return new (t || ContenteditableModule)(); };
ContenteditableModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ContenteditableModule });
ContenteditableModule.ɵinj = ɵngcc0.ɵɵdefineInjector({});
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ContenteditableModule, { declarations: [ContenteditableDirective], exports: [ContenteditableDirective] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContenteditableModule, [{
        type: NgModule,
        args: [{
                declarations: [ContenteditableDirective],
                exports: [ContenteditableDirective]
            }]
    }], null, null); })();

/*
 * Public API Surface of contenteditable
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ContenteditableDirective, ContenteditableModule };

//# sourceMappingURL=ng-stack-contenteditable.js.map